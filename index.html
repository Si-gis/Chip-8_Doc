<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="generator" content="mkdocs-1.6.0, mkdocs-terminal-4.4.0">
     
     
    <link rel="icon" type="image/png" sizes="192x192" href="img/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="img/android-chrome-512x512.png" />
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png" />
<link rel="shortcut icon" type="image/png" sizes="48x48" href="img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png" />


    
 
<title>Introduzione - Chip-8 Docs</title>


<link href="css/fontawesome/css/fontawesome.min.css" rel="stylesheet">
<link href="css/fontawesome/css/solid.min.css" rel="stylesheet">
<link href="css/normalize.css" rel="stylesheet">
<link href="css/terminal.css" rel="stylesheet">
<link href="css/theme.css" rel="stylesheet">
<link href="css/theme.tile_grid.css" rel="stylesheet">
<link href="css/theme.footer.css" rel="stylesheet">
<!-- pink color palette -->
<link href="css/palettes/pink.css" rel="stylesheet">

<!-- page layout -->
<style>
/* initially set page layout to a one column grid */
.terminal-mkdocs-main-grid {
    display: grid;
    grid-column-gap: 1.4em;
    grid-template-columns: auto;
    grid-template-rows: auto;
}

/*  
*   when side navigation is not hidden, use a two column grid.  
*   if the screen is too narrow, fall back to the initial one column grid layout.
*   in this case the main content will be placed under the navigation panel. 
*/
@media only screen and (min-width: 70em) {
    .terminal-mkdocs-main-grid {
        grid-template-columns: 4fr 9fr;
    }
}</style>

<!-- cursor_animation override -->
<style>
  #mkdocs-terminal-site-name.terminal-prompt::after {
      display: none;
  }
</style><!-- link underline override -->
<style>
#terminal-mkdocs-main-content a:not(.headerlink){
    text-decoration: none;
}
</style>

     
    
    

    
    
    
    
    

    
</head>

<body class="terminal"><div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div id="mkdocs-terminal-site-name" class="logo terminal-prompt"><a href="/" class="no-style">Chip-8 Docs</a></div>
        </header>
        
        <nav class="terminal-menu">
            
        </nav>
    </div>
</div>
        
    <div class="container">
        <div class="terminal-mkdocs-main-grid"><aside id="terminal-mkdocs-side-panel"><nav>
  
</nav><hr>
<nav>
    <ul>
        <li><a href="#introduzione">Introduzione</a></li>
        <li><a href="#requisiti">Requisiti</a></li><li><a href="#cose-il-chip-8">Cos'è il Chip-8</a></li><li><a href="#come-funziona-la-cpu">Come funziona la CPU</a></li><li><a href="#cosa-fa-un-emulatore">Cosa fa un emulatore</a></li><li><a href="#componenti-del-chip-8">Componenti del Chip-8</a></li><li><a href="#iniziamo-a-scrivere-il-codice">Iniziamo a scrivere il codice</a></li><li><a href="#caricare-i-fonts">Caricare i fonts</a></li><li><a href="#caricare-una-rom">Caricare una ROM</a></li><li><a href="#le-istruzioni">Le istruzioni</a></li><li><a href="#fetch-decode-execute">Fetch, Decode, Execute</a></li><li><a href="#sdl">SDL</a></li><li><a href="#loop-principale">Loop Principale</a></li><li><a href="#fonti">Fonti</a></li>
    </ul>
</nav>
</aside>
            <main id="terminal-mkdocs-main-content">
<section id="mkdocs-terminal-content">
    <h1 id="introduzione">Introduzione</h1>
<p>La programmazione low-level può spaventare data la sua difficoltà. 
Con questa guida, voglio togliere tutti i dubbi a riguardo. Partirò dalle basi, non lasciando nulla per scontato, e con molti approfondimenti low-level. L'obiettivo di questa documentazione è quello di scrivere un emulatore del chip-8 con C++.</p>
<h2 id="requisiti">Requisiti</h2>
<p>È consigliato avere delle conoscenze dei componenti di un PC ed è necessario conoscere le basi di C++.</p>
<h2 id="cose-il-chip-8">Cos'è il Chip-8</h2>
<p>Il chip-8 in realtà non è una macchina fisica, ma bensì una macchina virtuale. Questo rende la scrittura dell'emulatore più semplice rispetto, per esempio, a quella di un Game Boy, poiché non dovremo emulare hardware fisico. Di conseguenza, questo emulatore può essere considerato come un interprete, il quale avrà il ruolo di interpretare i programmi (ROM) scritti per l'architettura del chip-8.</p>
<h2 id="come-funziona-la-cpu">Come funziona la CPU</h2>
<p>È fondamentale comprendere come funziona la CPU per poter capire appieno l'emulatore. La CPU legge istruzioni dalla memoria (RAM e ROM). Prima, le istruzioni del gioco contenute nella memoria ROM vengono passate alla memoria RAM. Infine, la CPU prende le informazioni dalla RAM e le esegue. La CPU ha bisogno di istruzioni ben precise, quindi è cruciale scrivere correttamente e in modo accurato l'emulatore.</p>
<h2 id="cosa-fa-un-emulatore">Cosa fa un emulatore</h2>
<p>Un emulatore legge le istruzioni in codice macchina che sono state scritte per la specifica console. Dopo le interpreta e poi replica le funzionalità della macchina che si sta emulando sulla nostra. Le ROM contengono le istruzioni, l'emulatore le legge e successivamente emula la macchina originale.</p>
<h2 id="componenti-del-chip-8">Componenti del Chip-8</h2>
<h3 id="16-registri-8-bit">16 registri 8-bit</h3>
<p>I registri sono una parte dedicata allo storage, ma solo per operazioni temporanee (pochi KB di spazio), mentre i dati a lungo termine sono contenuti in una memoria di massa come SSD o HDD. In questo caso, le operazioni sono dei caricamenti di dati dalla memoria nei registri, operare nei registri e successivamente immagazzinare il risultato nella memoria. I registri del Chip-8 vanno dal V0 al VF. Ogni registro può avere un valore da 0x00 a 0xFF.</p>
<h3 id="4k-bytes-di-memoria-ram">4K Bytes di memoria RAM</h3>
<p>I registri hanno troppo poco spazio per mantenere dati a lungo termine. Qui entra in gioco la RAM, la quale nel caso del chip-8 funge sia da magazzino per le istruzioni del programma in esecuzione, sia per mantenere dati a lungo termine. Per accedere alle locazioni specifiche della memoria RAM, la CPU usa gli indirizzi. Infatti, ogni locazione di memoria ha un indirizzo specifico per poter accedervi. Avendo 4K byte di memoria, lo spazio degli indirizzi di memoria va da 0x000 a 0xFFF.</p>
<h3 id="registro-index-16-bit">Registro index 16-bit</h3>
<p>Viene usato per immagazzinare degli indirizzi di memoria da usare nelle operazioni. Il massimo valore degli indirizzi di memoria è 0xFFF.</p>
<h3 id="16-bit-program-counter">16-bit Program Counter</h3>
<p>È un registro che tiene gli indirizzi di memoria della successiva istruzione da eseguire.</p>
<h3 id="16-level-stack">16-level Stack</h3>
<p>Uno stack viene usato dalla CPU per tenere traccia dell'ordine di esecuzione quando chiama delle funzioni. Il chip-8 ha 16 livelli di stack, questo implica che possono essere memorizzati 16 valori del Program Counter (PC).</p>
<h3 id="8-bit-timer">8-bit Timer</h3>
<p>Il Chip-8 ha un timer integrato. Se gli viene caricato un valore, si decrementerà ad una frequenza di 60Hz. </p>
<h3 id="8-bit-timer-del-suono">8-bit Timer del suono</h3>
<p>È un altro timer utilizzato per i suoni. Funziona come l'altro timer, ovvero si decrementa a 60Hz se non è zero.</p>
<h3 id="16-input-keys">16 Input Keys</h3>
<p>Il Chip-8 ha 16 tasti per l'input, i quali corrispondono ai primi 16 valori esadecimali.</p>
<h3 id="memoria-display-monocromatico-64x32-pixel">Memoria Display Monocromatico 64x32 Pixel</h3>
<p>Il chip-8 ha un'ulteriore memoria dedicata al memorizzare i grafici da visualizzare. Rappresenta uno schermo di 64x32 pixel. Possono essere visualizzati solo due colori, ovvero il bianco e il nero. Per disegnare a schermo, il Chip-8 usa l'operazione XOR.</p>
<h2 id="iniziamo-a-scrivere-il-codice">Iniziamo a scrivere il codice</h2>
<h3 id="definiamo-i-membri-della-classe">Definiamo i membri della classe</h3>
<p>Qui abbiamo tutti i componenti che ho spiegato in precedenza.</p>
<pre><code>`
``#include &lt;cstdint&gt;`

`class Chip8 {`
`public:`
    `uint8_t registers[16]{};       // 16 registri V0-VF`
    `uint8_t memory[4096]{};        // Memoria di 4096 byte`
    `uint16_t index{};              // Puntatore di indice`
    `uint16_t pc{};                 // Contatore di programma`
    `uint16_t stack[16]{};          // Stack`
    `uint8_t sp{};                  // Puntatore dello stack`
    `uint8_t delayTimer{};          // Timer di ritardo`
    `uint8_t soundTimer{};          // Timer del suono`
    `uint8_t keypad[16]{};          // Tastiera`
    `uint32_t video[64 * 32]{};     // Buffer video`
    `uint16_t opcode;               // Opcode corrente`
`};`
</code></pre>
<h2 id="caricare-i-fonts">Caricare i fonts</h2>
<p>I caratteri sono rappresentati come sprite e ogni sprite è costituito da 5 byte. </p>
<pre><code class="language-cpp">const unsigned int FONTSET_SIZE = 80;

uint8_t fontset[FONTSET_SIZE] =
{
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};
</code></pre>
<h3 id="per-caricare-la-memoria">Per caricare la memoria</h3>
<pre><code>const unsigned int FONTSET_START_ADDRESS = 0x50;

Chip8::Chip8()
{
    [...]

    // Load fonts into memory
    for (unsigned int i = 0; i &lt; FONTSET_SIZE; ++i)
    {
        memory[FONTSET_START_ADDRESS + i] = fontset[i];
    }
}
</code></pre>
<h2 id="caricare-una-rom">Caricare una ROM</h2>
<p>Questa parte di codice serve a caricare una ROM da far eseguire al Chip-8</p>
<pre><code>`#include &lt;fstream&gt;`

`const unsigned int START_ADDRESS = 0x200;`

`void Chip8::LoadROM(char const* filename) {`

    `std::ifstream file(filename, std::ios::binary | std::ios::ate);`

    `if (file.is_open()) {`
        `std::streampos size = file.tellg();`
        `char* buffer = new char[size];`
        `file.seekg(0, std::ios::beg);`
        `file.read(buffer, size);`
        `file.close();`
        `for (long i = 0; i &lt; size; ++i) {`
            `memory[START_ADDRESS + i] = buffer[i];`
        `}`

        `delete[] buffer;`
    `}`
`}`
</code></pre>
<h2 id="le-istruzioni">Le istruzioni</h2>
<p>Il chip-8 ha 34 istruzioni che dobbiamo emulare.
- <strong>0nnn - SYS addr</strong>
- <strong>00E0 - CLS</strong>
- <strong>00EE - RET</strong>
- <strong>1nnn - JP addr</strong>
- <strong>2nnn - CALL addr</strong>
- <strong>3xkk - SE Vx, byte</strong>
- <strong>4xkk - SNE Vx, byte</strong>
- <strong>5xy0 - SE Vx, Vy</strong>
- <strong>6xkk - LD Vx, byte</strong>
- <strong>7xkk - ADD Vx, byte</strong>
- <strong>8xy0 - LD Vx, Vy</strong>
- <strong>8xy1 - OR Vx, Vy</strong>
- <strong>8xy2 - AND Vx, Vy</strong>
- <strong>8xy3 - XOR Vx, Vy</strong>
- <strong>8xy4 - ADD Vx, Vy</strong>
- <strong>8xy5 - SUB Vx, Vy</strong>
- <strong>8xy6 - SHR Vx {, Vy}</strong>
- <strong>8xy7 - SUBN Vx, Vy</strong>
- <strong>8xyE - SHL Vx {, Vy}</strong>
- <strong>9xy0 - SNE Vx, Vy</strong>
- <strong>Annn - LD I, addr</strong>
- <strong>Bnnn - JP V0, addr</strong>
- <strong>Cxkk - RND Vx, byte</strong>
- <strong>Dxyn - DRW Vx, Vy, nibble</strong>
- <strong>Ex9E - SKP Vx</strong>
- <strong>ExA1 - SKNP Vx</strong>
- <strong>Fx07 - LD Vx, DT</strong>
- <strong>Fx0A - LD Vx, K</strong>
- <strong>Fx15 - LD DT, Vx</strong>
- <strong>Fx18 - LD ST, Vx</strong>
- <strong>Fx1E - ADD I, Vx</strong>
- <strong>Fx29 - LD F, Vx</strong>
- <strong>Fx33 - LD B, Vx</strong>
- <strong>Fx55 - LD [I], Vx</strong>
- **Fx65 - LD Vx, [I]</p>
<h2 id="fetch-decode-execute">Fetch, Decode, Execute</h2>
<p>Il ciclo che effettua una CPU nel contesto di CHIP-8 è divisa in tre fasi principali: <strong>fetch</strong>, <strong>decode</strong> ed <strong>execute</strong>.  Vediamole:</p>
<h3 id="fetch">Fetch</h3>
<p>Durante la fase di fetch, l'emulatore legge la prossima istruzione dalla memoria.
La seguente riga di codice realizza questa operazione:
`opcode = (memory[pc] &lt;&lt; 8u) | memory[pc + 1];</p>
<h3 id="decode">Decode</h3>
<p>Nella fase di decodifica, l'istruzione prelevata viene interpretata per determinare quale operazione eseguire. La seguente riga di codice realizza questa operazione:
<code>((*this).*(table[(opcode &amp; 0xF000u) &gt;&gt; 12u]))();</code></p>
<h3 id="execute">Execute</h3>
<p>Durante la fase di esecuzione, la funzione individuata nella fase di decodifica viene chiamata per eseguire l'istruzione.</p>
<h2 id="sdl">SDL</h2>
<p>SDL è una libreria che viene usata per renderizzare e ottenere gli input.
class Platform</p>
<pre><code>`{`
`public:`
    `Platform(char const* title, int windowWidth, int windowHeight, int textureWidth, int textureHeight)`
    `{`
        `SDL_Init(SDL_INIT_VIDEO);`

        `window = SDL_CreateWindow(title, 0, 0, windowWidth, windowHeight, SDL_WINDOW_SHOWN);`

        `renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);`

        `texture = SDL_CreateTexture(`
            `renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STREAMING, textureWidth, textureHeight);`
    `}`

    `~Platform()`
    `{`
        `SDL_DestroyTexture(texture);`
        `SDL_DestroyRenderer(renderer);`
        `SDL_DestroyWindow(window);`
        `SDL_Quit();`
    `}`

    `void Update(void const* buffer, int pitch)`
    `{`
        `SDL_UpdateTexture(texture, nullptr, buffer, pitch);`
        `SDL_RenderClear(renderer);`
        `SDL_RenderCopy(renderer, texture, nullptr, nullptr);`
        `SDL_RenderPresent(renderer);`
    `}`

    `bool ProcessInput(uint8_t* keys)`
    `{`
        `bool quit = false;`

        `SDL_Event event;`

        `while (SDL_PollEvent(&amp;event))`
        `{`
            `switch (event.type)`
            `{`
                `case SDL_QUIT:`
                `{`
                    `quit = true;`
                `} break;`

                `case SDL_KEYDOWN:`
                `{`
                    `switch (event.key.keysym.sym)`
                    `{`
                        `case SDLK_ESCAPE:`
                        `{`
                            `quit = true;`
                        `} break;`

                        `case SDLK_x:`
                        `{`
                            `keys[0] = 1;`
                        `} break;`
                        `// Aggiungi altre mappature dei tasti qui`
                    `}`
                `} break;`

                `case SDL_KEYUP:`
                `{`
                    `switch (event.key.keysym.sym)`
                    `{`
                        `case SDLK_x:`
                        `{`
                            `keys[0] = 0;`
                        `} break;`
                        `// Aggiungi altre mappature dei tasti qui`
                    `}`
                `} break;`
            `}`
        `}`

        `return quit;`
    `}`

`private:`
    `SDL_Window* window{};`
    `SDL_Renderer* renderer{};`
    `SDL_Texture* texture{};`
`};`
</code></pre>
<h2 id="loop-principale">Loop Principale</h2>
<p>Il cuore dell'emulatore. Questo ciclo continua a eseguire le istruzioni fino a quando l'utente decide di uscire. </p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;GL/glut.h&gt;
#include &quot;chip8.h&quot;

chip8 myChip8;

int main(int argc, char **argv) 
{
    setupGraphics();
    setupInput();

    myChip8.initialize();
    myChip8.loadGame(&quot;pong&quot;);

    for(;;)
    {
        myChip8.emulateCycle();

        if(myChip8.drawFlag)
            drawGraphics();

        myChip8.setKeys();    
    }

    return 0;
}

</code></pre>
<h2 id="fonti">Fonti</h2>
<p>https://tobiasvl.github.io/blog/write-a-chip-8-emulator/</p>
<p>https://austinmorlan.com/posts/chip8_emulator/#function-pointer-table</p>
<p>https://multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/</p>
</section>

            </main>
        </div>
        <hr><footer>
    <div class="terminal-mkdocs-footer-grid">
        <div id="terminal-mkdocs-footer-copyright-info">
             Site built with <a href="http://www.mkdocs.org">MkDocs</a> and <a href="https://github.com/ntno/mkdocs-terminal">Terminal for MkDocs</a>.
        </div>
    </div>
</footer>
    </div>

    
    
    
</body>

</html>